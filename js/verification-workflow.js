/**
 * Physical Verification Workflow System
 * Manages the process of physically checking phantom inventory candidates
 */

const fs = require('fs').promises;
const path = require('path');
const ExcelJS = require('exceljs');

class VerificationWorkflow {
    constructor(storeId, phantomML) {
        this.storeId = storeId;
        this.phantomML = phantomML;
        this.verificationQueue = [];
        this.activeVerifications = new Map();
        this.completedVerifications = new Map();
        this.verificationConfig = {
            maxDailyVerifications: 50,
            priorityThreshold: 80,
            batchSize: 10,
            autoGenerateDaily: true,
            itemsPerSheet: 50  // New: Items per verification sheet
        };
        this.workflowFile = `verification_workflow_${storeId}.json`;
        
        // New: Sheet management
        this.verificationSheets = new Map(); // Store multiple sheets
        this.currentSheetIndex = 0;
        this.completedSheets = new Set(); // Track completed sheets
    }

    /**
     * Generate daily verification list based on phantom inventory analysis
     */
    async generateDailyVerificationList(phantomCandidates) {
        console.log(`Generating daily verification list for store ${this.storeId}`);
        
        // Since we're now receiving pre-analyzed phantom candidates, we don't need to re-analyze
        const candidates = phantomCandidates.map(item => ({
            partNumber: item.partNumber || item.PARTNUMBER,
            description: item.description || item.DESCRIPTION1 || 'No Description',
            currentStock: parseInt(item.currentStock || item.STOCKONHAND || 0),
            unitCost: parseFloat(item.unitCost || item.UNITCOST || 0),
            location: item.location || item.LOCATIONID || '',
            supplier: item.supplier || item.SUPPLIER_NUMBER1 || '',
            riskScore: item.riskScore || 50, // Default risk score if not provided
            verificationPriority: item.verificationPriority || this.calculateVerificationPriority(item),
            riskFactors: item.riskFactors || ['System identified as phantom candidate'],
            category: item.category || 'unknown',
            estimatedTime: this.estimateVerificationTime(item),
            generatedAt: new Date().toISOString()
        }));

        // Sort by verification priority
        candidates.sort((a, b) => b.verificationPriority - a.verificationPriority);

        // NEW: Create verification sheets from candidates
        const verificationSheets = this.createVerificationSheets(candidates);
        
        // Store sheets in the workflow
        this.verificationSheets = verificationSheets;
        this.currentSheetIndex = 0;
        this.completedSheets.clear();

        // Group by location for efficient checking (for backward compatibility)
        const firstSheet = verificationSheets.get(0);
        const locationGroups = firstSheet ? this.groupByLocation(firstSheet.items) : {};

        // Save workflow state
        await this.saveWorkflowState();

        console.log(`Generated ${candidates.length} items across ${verificationSheets.size} verification sheets`);
        
        // Convert locationGroups object to array format for easier handling
        const locationGroupsArray = Object.keys(locationGroups).map(location => ({
            location: location,
            items: locationGroups[location]
        }));
        
        return {
            totalCandidates: candidates.length,
            dailyList: firstSheet ? firstSheet.items.length : 0, // Items in first sheet
            locationGroups: locationGroupsArray,
            estimatedTime: firstSheet ? firstSheet.items.reduce((sum, item) => sum + item.estimatedTime, 0) : 0,
            highPriorityItems: firstSheet ? firstSheet.items.filter(item => item.verificationPriority >= this.verificationConfig.priorityThreshold).length : 0,
            filename: null, // Will be generated when needed
            items: firstSheet ? firstSheet.items : [], // Items in first sheet
            // NEW: Sheet management info
            totalSheets: verificationSheets.size,
            currentSheet: 0,
            verificationSheets: Array.from(verificationSheets.values()).map(sheet => ({
                id: sheet.id,
                name: sheet.name,
                itemCount: sheet.items.length,
                status: sheet.status,
                priority: sheet.priority
            }))
        };
    }

    /**
     * Generate unique verification ID
     */
    generateVerificationId(partNumber) {
        const timestamp = Date.now().toString(36);
        const random = Math.random().toString(36).substring(2, 5);
        return `VER-${this.storeId}-${timestamp}-${random}`;
    }

    /**
     * Estimate time required for verification
     */
    estimateVerificationTime(item, analysis) {
        let baseTime = 3; // 3 minutes base time
        
        // Add time for high-value items (more careful checking)
        if (item.UNITCOST > 100) baseTime += 2;
        else if (item.UNITCOST > 50) baseTime += 1;
        
        // Add time for complex locations
        const location = (item.LOCATIONID || '').toUpperCase();
        if (location.includes('STORAGE') || location.includes('WAREHOUSE')) baseTime += 2;
        if (location.includes('HIGH') || location.includes('LADDER')) baseTime += 1;
        
        // Add time for multiple risk factors
        if (analysis.riskFactors.length > 3) baseTime += 1;
        
        return baseTime;
    }

    /**
     * Group items by location for efficient verification
     */
    groupByLocation(items) {
        const groups = {};
        
        items.forEach(item => {
            const location = this.normalizeLocation(item.location);
            if (!groups[location]) {
                groups[location] = [];
            }
            groups[location].push(item);
        });

        return groups;
    }

    /**
     * Normalize location for grouping
     */
    normalizeLocation(location) {
        if (!location) return 'UNKNOWN';
        
        const normalized = location.toUpperCase();
        
        // Group similar locations
        if (normalized.includes('AISLE')) {
            const aisleMatch = normalized.match(/AISLE\s*(\d+)/);
            return aisleMatch ? `AISLE_${aisleMatch[1]}` : 'AISLE_UNKNOWN';
        }
        
        if (normalized.includes('STORAGE')) return 'STORAGE';
        if (normalized.includes('WAREHOUSE')) return 'WAREHOUSE';
        if (normalized.includes('COUNTER')) return 'COUNTER';
        if (normalized.includes('DISPLAY')) return 'DISPLAY';
        
        return normalized.substring(0, 10); // Limit length
    }

    /**
     * Get location group for an item
     */
    getLocationGroup(location, locationGroups) {
        const normalized = this.normalizeLocation(location);
        return Object.keys(locationGroups).find(group => group === normalized) || 'UNKNOWN';
    }

    /**
     * Generate verification sheets for printing
     */
    async generateVerificationSheets(locationGroups) {
        try {
            const ExcelJS = require('exceljs');
            const workbook = new ExcelJS.Workbook();
            
            // Create single verification sheet for all items
            const verificationSheet = workbook.addWorksheet('Verification List');
            verificationSheet.columns = [
                {header: 'Part Number', key: 'itemNumber', width: 18},
                {header: 'Description', key: 'description', width: 45},
                {header: 'Current Stock', key: 'currentStock', width: 16},
                {header: 'Physical Count', key: 'physicalCount', width: 18},
                {header: 'Notes', key: 'notes', width: 25},
                {header: 'Verified By', key: 'verifiedBy', width: 20},
                {header: 'Date', key: 'date', width: 15}
            ];

            // Collect all items from all locations and sort by part number
            const allItems = [];
            for (const [location, items] of Object.entries(locationGroups)) {
                allItems.push(...items);
            }

            // Sort all items by part number for easier lookup
            allItems.sort((a, b) => a.partNumber.localeCompare(b.partNumber));

            // Add all items to the sheet
            verificationSheet.addRows(allItems.map(item => ({
                itemNumber: item.partNumber,
                description: item.description,
                currentStock: item.currentStock,
                physicalCount: '',
                notes: '',
                verifiedBy: '',
                date: ''
            })));

            // Apply borders to all cells for better printing
            const borderStyle = {
                top: { style: 'thin' },
                left: { style: 'thin' },
                bottom: { style: 'thin' },
                right: { style: 'thin' }
            };

            // Apply enhanced formatting to all cells
            const dataRange = verificationSheet.getRows(1, allItems.length + 1);
            dataRange.forEach(row => {
                row.eachCell({ includeEmpty: true }, (cell, colNumber) => {
                    cell.border = borderStyle;
                    
                    // Make header row bold and centered
                    if (row.number === 1) {
                        cell.font = { bold: true };
                        cell.alignment = { horizontal: 'center', vertical: 'middle' };
                    } else {
                        // Center align Current Stock column (column 3) and Physical Count (column 4)
                        if (colNumber === 3 || colNumber === 4) {
                            cell.alignment = { horizontal: 'center', vertical: 'middle' };
                        } else {
                            cell.alignment = { horizontal: 'left', vertical: 'middle' };
                        }
                    }
                });
                
                // Set row height for better visibility
                row.height = 22;
            });

            // Auto-size columns based on content and headers
            const headers = ['Part Number', 'Description', 'Current Stock', 'Physical Count', 'Notes', 'Verified By', 'Date'];
            headers.forEach((header, index) => {
                const column = verificationSheet.getColumn(index + 1);
                const headerLength = header.length;
                let maxContentLength = headerLength;
                
                // Check content length in this column
                column.eachCell({ includeEmpty: false }, cell => {
                    if (cell.value && cell.row > 1) { // Skip header row
                        const contentLength = cell.value.toString().length;
                        if (contentLength > maxContentLength) {
                            maxContentLength = contentLength;
                        }
                    }
                });
                
                // Set column width with padding, ensuring headers fit
                column.width = Math.max(maxContentLength + 3, headerLength + 2);
            });

            // Create summary sheet for overview
            const summarySheet = workbook.addWorksheet('Summary');
            summarySheet.columns = [
                {header: 'Location', key: 'location', width: 20},
                {header: 'Items to Verify', key: 'itemCount', width: 15},
                {header: 'Estimated Time', key: 'estimatedTime', width: 15}
            ];

            // Add summary data
            summarySheet.addRows(Object.entries(locationGroups).map(([location, items]) => ({
                location,
                itemCount: items.length,
                estimatedTime: `${Math.ceil(items.length * 2)} minutes`
            })));

            // Save file to desktop with fallback
            const os = require('os');
            const path = require('path');
            const fs = require('fs');
            
            const today = new Date();
            const dateString = today.toISOString().split('T')[0];
            const filename = `Phantom_Inventory_Verification_${this.storeId}_${dateString}.xlsx`;
            
            let filepath;
            const desktopPath = path.join(os.homedir(), 'Desktop');
            
            if (fs.existsSync(desktopPath)) {
                filepath = path.join(desktopPath, filename);
            } else {
                filepath = path.join(process.cwd(), filename);
            }
            
            await workbook.xlsx.writeFile(filepath);
            
            // Auto-open the file
            const { shell } = require('electron');
            shell.openPath(filepath);
            
            console.log(`Generated verification sheets saved to desktop: ${filepath}`);
            console.log(`Generated ${allItems.length} items for verification across ${Object.keys(locationGroups).length} location groups`);
            
            return {
                filename: filepath,
                itemCount: allItems.length,
                locationCount: Object.keys(locationGroups).length
            };
        } catch (error) {
            console.error('Error generating verification sheets:', error);
            throw error;
        }
    }

    /**
     * Start verification process for an item
     */
    async startVerification(verificationId, assignedTo) {
        const verification = this.verificationQueue.find(v => v.id === verificationId);
        if (!verification) {
            throw new Error(`Verification ${verificationId} not found`);
        }

        verification.status = 'in_progress';
        verification.assignedTo = assignedTo;
        verification.startedAt = new Date().toISOString();

        this.activeVerifications.set(verificationId, verification);
        
        await this.saveWorkflowState();
        
        return verification;
    }

    /**
     * Complete verification with results
     */
    async completeVerification(verificationId, results) {
        const verification = this.activeVerifications.get(verificationId);
        if (!verification) {
            throw new Error(`Active verification ${verificationId} not found`);
        }

        const completedVerification = {
            ...verification,
            status: 'completed',
            completedAt: new Date().toISOString(),
            results: {
                physicalCount: results.physicalCount,
                discrepancy: results.physicalCount - verification.currentStock,
                notes: results.notes || '',
                verifiedBy: results.verifiedBy || verification.assignedTo,
                adjustmentRequired: results.physicalCount !== verification.currentStock,
                adjustmentValue: (results.physicalCount - verification.currentStock) * verification.unitCost
            }
        };

        // Move to completed
        this.completedVerifications.set(verificationId, completedVerification);
        this.activeVerifications.delete(verificationId);

        // Remove from queue
        this.verificationQueue = this.verificationQueue.filter(v => v.id !== verificationId);

        // Record result in ML system
        await this.phantomML.recordVerificationResult(
            verification.partNumber,
            {
                riskScore: verification.riskScore,
                isPhantomInventoryCandidate: true,
                riskFactors: verification.riskFactors,
                systemStock: verification.currentStock
            },
            results.physicalCount,
            results.notes
        );

        await this.saveWorkflowState();

        console.log(`Completed verification for ${verification.partNumber}: ${verification.currentStock} â†’ ${results.physicalCount}`);
        
        return completedVerification;
    }

    /**
     * Batch complete multiple verifications
     */
    async batchCompleteVerifications(verificationResults) {
        const results = [];
        
        for (const result of verificationResults) {
            try {
                const completed = await this.completeVerification(result.verificationId, result);
                results.push({ success: true, verification: completed });
            } catch (error) {
                results.push({ success: false, error: error.message, verificationId: result.verificationId });
            }
        }

        return results;
    }

    /**
     * Get verification statistics
     */
    getVerificationStats() {
        const stats = {
            pending: this.verificationQueue.length,
            inProgress: this.activeVerifications.size,
            completed: this.completedVerifications.size,
            totalDiscrepancies: 0,
            totalAdjustmentValue: 0,
            accuracyRate: 0,
            averageVerificationTime: 0,
            categoryBreakdown: {},
            locationBreakdown: {}
        };

        // Calculate statistics from completed verifications
        const completed = Array.from(this.completedVerifications.values());
        
        if (completed.length > 0) {
            stats.totalDiscrepancies = completed.filter(v => v.results.adjustmentRequired).length;
            stats.totalAdjustmentValue = completed.reduce((sum, v) => sum + Math.abs(v.results.adjustmentValue), 0);
            stats.accuracyRate = ((completed.length - stats.totalDiscrepancies) / completed.length) * 100;
            
            // Calculate average verification time
            const verificationTimes = completed
                .filter(v => v.startedAt && v.completedAt)
                .map(v => new Date(v.completedAt) - new Date(v.startedAt));
            
            if (verificationTimes.length > 0) {
                stats.averageVerificationTime = verificationTimes.reduce((sum, time) => sum + time, 0) / verificationTimes.length / 1000 / 60; // minutes
            }

            // Category breakdown
            completed.forEach(v => {
                const category = v.category || 'unknown';
                if (!stats.categoryBreakdown[category]) {
                    stats.categoryBreakdown[category] = { total: 0, discrepancies: 0 };
                }
                stats.categoryBreakdown[category].total++;
                if (v.results.adjustmentRequired) {
                    stats.categoryBreakdown[category].discrepancies++;
                }
            });

            // Location breakdown
            completed.forEach(v => {
                const location = v.locationGroup || 'unknown';
                if (!stats.locationBreakdown[location]) {
                    stats.locationBreakdown[location] = { total: 0, discrepancies: 0 };
                }
                stats.locationBreakdown[location].total++;
                if (v.results.adjustmentRequired) {
                    stats.locationBreakdown[location].discrepancies++;
                }
            });
        }

        return stats;
    }

    /**
     * Generate verification report
     */
    async generateVerificationReport() {
        const stats = this.getVerificationStats();
        const workbook = new ExcelJS.Workbook();
        
        // Summary sheet
        const summarySheet = workbook.addWorksheet('Verification Summary');
        summarySheet.addRow(['Verification Statistics', '']);
        summarySheet.addRow(['Total Pending', stats.pending]);
        summarySheet.addRow(['Total In Progress', stats.inProgress]);
        summarySheet.addRow(['Total Completed', stats.completed]);
        summarySheet.addRow(['Total Discrepancies', stats.totalDiscrepancies]);
        summarySheet.addRow(['Accuracy Rate', `${stats.accuracyRate.toFixed(1)}%`]);
        summarySheet.addRow(['Total Adjustment Value', `$${stats.totalAdjustmentValue.toFixed(2)}`]);
        summarySheet.addRow(['Avg Verification Time', `${stats.averageVerificationTime.toFixed(1)} minutes`]);

        // Detailed results sheet
        const detailsSheet = workbook.addWorksheet('Verification Details');
        detailsSheet.columns = [
            { header: 'Part Number', key: 'partNumber', width: 15 },
            { header: 'Description', key: 'description', width: 30 },
            { header: 'System Stock', key: 'systemStock', width: 12 },
            { header: 'Physical Count', key: 'physicalCount', width: 15 },
            { header: 'Discrepancy', key: 'discrepancy', width: 12 },
            { header: 'Adjustment Value', key: 'adjustmentValue', width: 15 },
            { header: 'Category', key: 'category', width: 15 },
            { header: 'Location', key: 'location', width: 15 },
            { header: 'Verified By', key: 'verifiedBy', width: 15 },
            { header: 'Completed At', key: 'completedAt', width: 20 },
            { header: 'Notes', key: 'notes', width: 30 }
        ];

        // Add completed verifications
        Array.from(this.completedVerifications.values()).forEach(verification => {
            detailsSheet.addRow({
                partNumber: verification.partNumber,
                description: verification.description,
                systemStock: verification.currentStock,
                physicalCount: verification.results.physicalCount,
                discrepancy: verification.results.discrepancy,
                adjustmentValue: verification.results.adjustmentValue.toFixed(2),
                category: verification.category,
                location: verification.location,
                verifiedBy: verification.results.verifiedBy,
                completedAt: verification.completedAt,
                notes: verification.results.notes
            });
        });

        // Save report
        const timestamp = new Date().toISOString().split('T')[0];
        const filename = `Verification_Report_${this.storeId}_${timestamp}.xlsx`;
        await workbook.xlsx.writeFile(filename);
        
        return { filename, stats };
    }

    /**
     * Calculate verification priority for an item
     */
    calculateVerificationPriority(item) {
        let priority = 50; // Base priority
        
        const riskScore = item.riskScore || 0;
        const currentStock = parseInt(item.currentStock || item.STOCKONHAND || 0);
        const unitCost = parseFloat(item.unitCost || item.UNITCOST || 0);
        
        // Higher risk = higher priority
        priority += riskScore * 0.3;
        
        // Higher value items = higher priority
        const itemValue = currentStock * unitCost;
        if (itemValue > 1000) priority += 20;
        else if (itemValue > 500) priority += 10;
        else if (itemValue > 100) priority += 5;
        
        // Higher stock quantities = higher priority
        if (currentStock > 50) priority += 15;
        else if (currentStock > 20) priority += 10;
        else if (currentStock > 5) priority += 5;
        
        return Math.min(Math.max(priority, 0), 100); // Clamp between 0-100
    }

    /**
     * Estimate verification time for an item
     */
    estimateVerificationTime(item) {
        const currentStock = parseInt(item.currentStock || item.STOCKONHAND || 0);
        const location = (item.location || item.LOCATIONID || '').toUpperCase();
        
        let baseTime = 2; // 2 minutes base time
        
        // More stock takes longer to count
        if (currentStock > 20) baseTime += 3;
        else if (currentStock > 10) baseTime += 2;
        else if (currentStock > 5) baseTime += 1;
        
        // Some locations are harder to access
        if (location.includes('STORAGE') || location.includes('WAREHOUSE')) {
            baseTime += 2;
        } else if (location.includes('HIGH') || location.includes('SHELF')) {
            baseTime += 1;
        }
        
        return baseTime;
    }

    /**
     * Save workflow state
     */
    async saveWorkflowState() {
        try {
            const state = {
                storeId: this.storeId,
                verificationQueue: this.verificationQueue,
                activeVerifications: Array.from(this.activeVerifications.entries()),
                completedVerifications: Array.from(this.completedVerifications.entries()),
                // NEW: Sheet management state
                verificationSheets: Array.from(this.verificationSheets.entries()),
                currentSheetIndex: this.currentSheetIndex,
                completedSheets: Array.from(this.completedSheets),
                lastUpdated: new Date().toISOString()
            };

            await fs.writeFile(this.workflowFile, JSON.stringify(state, null, 2));
        } catch (error) {
            console.error(`Error saving workflow state: ${error.message}`);
        }
    }

    /**
     * Load workflow state
     */
    async loadWorkflowState() {
        try {
            const data = await fs.readFile(this.workflowFile, 'utf8');
            const state = JSON.parse(data);
            
            this.verificationQueue = state.verificationQueue || [];
            this.activeVerifications = new Map(state.activeVerifications || []);
            this.completedVerifications = new Map(state.completedVerifications || []);
            
            // NEW: Load sheet management state
            if (state.verificationSheets) {
                this.verificationSheets = new Map(state.verificationSheets);
                this.currentSheetIndex = state.currentSheetIndex || 0;
                this.completedSheets = new Set(state.completedSheets || []);
            }
            
            console.log(`Loaded workflow state: ${this.verificationSheets.size} sheets, ${this.completedSheets.size} completed, current sheet: ${this.currentSheetIndex}`);
        } catch (error) {
            console.log('No existing workflow state found, starting fresh');
        }
    }

    /**
     * Schedule daily verification list generation
     */
    scheduleDailyGeneration(inventoryDataCallback) {
        if (!this.verificationConfig.autoGenerateDaily) return;

        // Generate at 6 AM daily
        const scheduleTime = new Date();
        scheduleTime.setHours(6, 0, 0, 0);
        
        const msUntilNext = scheduleTime.getTime() - Date.now();
        const msPerDay = 24 * 60 * 60 * 1000;
        
        setTimeout(() => {
            this.generateDailyVerificationList(inventoryDataCallback());
            
            // Then repeat daily
            setInterval(() => {
                this.generateDailyVerificationList(inventoryDataCallback());
            }, msPerDay);
        }, msUntilNext > 0 ? msUntilNext : msPerDay + msUntilNext);
        
        console.log(`Scheduled daily verification list generation at 6:00 AM`);
    }

    /**
     * NEW: Create verification sheets by batching candidates
     */
    createVerificationSheets(candidates) {
        const sheets = new Map();
        const itemsPerSheet = this.verificationConfig.itemsPerSheet;
        
        let sheetIndex = 0;
        for (let i = 0; i < candidates.length; i += itemsPerSheet) {
            const sheetItems = candidates.slice(i, i + itemsPerSheet);
            
            // Calculate sheet priority based on items
            const avgPriority = sheetItems.reduce((sum, item) => sum + item.verificationPriority, 0) / sheetItems.length;
            const highPriorityCount = sheetItems.filter(item => item.verificationPriority >= this.verificationConfig.priorityThreshold).length;
            
            const sheet = {
                id: sheetIndex,
                name: `Verification Sheet ${sheetIndex + 1}`,
                items: sheetItems,
                status: sheetIndex === 0 ? 'active' : 'pending',
                priority: avgPriority,
                highPriorityCount: highPriorityCount,
                estimatedTime: sheetItems.reduce((sum, item) => sum + item.estimatedTime, 0),
                createdAt: new Date().toISOString(),
                completedAt: null
            };
            
            sheets.set(sheetIndex, sheet);
            sheetIndex++;
        }
        
        return sheets;
    }

    /**
     * NEW: Get current verification sheet
     */
    getCurrentSheet() {
        return this.verificationSheets.get(this.currentSheetIndex);
    }

    /**
     * NEW: Get specific verification sheet by ID
     */
    getSheet(sheetId) {
        return this.verificationSheets.get(sheetId);
    }

    /**
     * NEW: Complete current verification sheet and move to next
     */
    async completeCurrentSheet(validationResults) {
        const currentSheet = this.getCurrentSheet();
        if (!currentSheet) {
            throw new Error('No current sheet to complete');
        }

        // Mark sheet as completed
        currentSheet.status = 'completed';
        currentSheet.completedAt = new Date().toISOString();
        currentSheet.validationResults = validationResults;

        this.completedSheets.add(currentSheet.id);

        // Move to next sheet if available
        const nextSheetIndex = this.currentSheetIndex + 1;
        if (this.verificationSheets.has(nextSheetIndex)) {
            this.currentSheetIndex = nextSheetIndex;
            const nextSheet = this.verificationSheets.get(nextSheetIndex);
            nextSheet.status = 'active';
            console.log(`Moved to verification sheet ${nextSheetIndex + 1}`);
        } else {
            console.log('All verification sheets completed');
        }

        await this.saveWorkflowState();
        
        return {
            completedSheet: currentSheet,
            nextSheet: this.getCurrentSheet(),
            hasNextSheet: this.verificationSheets.has(nextSheetIndex),
            totalSheets: this.verificationSheets.size,
            completedSheets: this.completedSheets.size
        };
    }

    /**
     * NEW: Select a specific sheet to work on
     */
    async selectSheet(sheetId) {
        if (!this.verificationSheets.has(sheetId)) {
            throw new Error(`Sheet ${sheetId} not found`);
        }

        // Mark current sheet as pending if not completed
        const oldSheet = this.getCurrentSheet();
        if (oldSheet && oldSheet.status === 'active') {
            oldSheet.status = 'pending';
        }

        // Activate selected sheet
        this.currentSheetIndex = sheetId;
        const newSheet = this.verificationSheets.get(sheetId);
        if (newSheet.status !== 'completed') {
            newSheet.status = 'active';
        }

        await this.saveWorkflowState();
        
        return newSheet;
    }

    /**
     * NEW: Get verification sheets summary
     */
    getSheetsSummary() {
        const sheets = Array.from(this.verificationSheets.values());
        
        return {
            totalSheets: sheets.length,
            completedSheets: this.completedSheets.size,
            currentSheet: this.currentSheetIndex,
            sheets: sheets.map(sheet => ({
                id: sheet.id,
                name: sheet.name,
                itemCount: sheet.items.length,
                status: sheet.status,
                priority: sheet.priority,
                highPriorityCount: sheet.highPriorityCount,
                estimatedTime: sheet.estimatedTime,
                completedAt: sheet.completedAt
            }))
        };
    }

    /**
     * NEW: Check if all sheets are completed
     */
    areAllSheetsCompleted() {
        return this.completedSheets.size === this.verificationSheets.size;
    }
}

module.exports = VerificationWorkflow; 